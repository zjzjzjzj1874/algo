
# 逻辑运算符 
## 与&
“与”运算符表示两个条件同时为真时，结果才为真。简单地说，就是所有输入都为真，结果才为真。

真值表

| A | B | A&B |
|---|---|-----|
| 0 | 0 | 0   |
| 0 | 1 | 0   |
| 1 | 0 | 0   |
| 1 | 1 | 1   |

## 或|
“或”运算符表示只要有一个条件为真，结果就是为真。换句话说，任何一个输入为真，结果就为真。

真值表

| A | B | A\|B |
|---|---|------|
| 0 | 0 | 0    |
| 0 | 1 | 1    |
| 1 | 0 | 1    |
| 1 | 1 | 1    |

## 非!
“非”运算符用于否定一个条件。简单来说，就是把真变为假，假变为真。

真值表

| A | !A |
|---|----|
| 0 | 1  |
| 1 | 0  |

## 异或^
“异或”运算符表示如果两个条件中只有一个为真，结果就为真；如果两个条件都相同（要么都为真，要么都为假），结果为假。
真值表

| A | B | A^B |
|---|---|-----|
| 0 | 0 | 0   |
| 0 | 1 | 1   |
| 1 | 0 | 1   |
| 1 | 1 | 0   |

* 任何数和他自己异或，值为0； => a^a = 0;
* 任何数和0异或，等于他本身； => a^0 = a;
- 交换律 a^b = b^a
- 结合律  a^b^c = a^(b^c)

## 其他
### 补码
在计算机中，负数通常以补码（Two's Complement）的形式表示。给定一个正整数 x，它的补码 -x 可以通过以下步骤计算：

1. 将 x 的所有位取反，得到 ~x。
2. 对取反的结果加1，即 -x = ~x + 1。

- 一个十进制数在其二进制表示中最右边的非零位的值
关键点：x & -x 的结果会保留 x 最右边的1位，其余位都为0。这个操作实际上是找出了 x 最右边的1位的位置。

```go
rightOne := (x & -x)
fmt.Println(rightOne)
```

# 基本排序算法
基于比较的有
**冒泡、插入、选择、归并、快排和堆排**；
排序算法的稳定性：相同值的元素之间，不因为排序而改变相对次序，这个排序就叫稳定排序，否则就是不稳定排序；
稳定排序：**冒泡、插入、归并**和桶排序思想下的排序；
不稳定排序：**选择、快排、堆排**

基于比较的排序适用范围更广；
桶排序则不存在这么广的适用范围。桶排序有计数排序和基数排序。
 
## 冒泡排序
[冒泡排序](./bubble.go)

## 插入排序
## 选择排序

## 归并排序
[归并排序-merge](./merge.go)

1. 整体就是一个简单的递归，左边排好序，右边排好序，让整体有序
2. 让整体有序的过程使用了外排序的方法 => 外排序：两指针比较的结果存入外部数组，排好序后写回原数组

时间复杂度 O(NlogN)
空间复杂度 O(N)

## 快排
[快速排序](./quick.go)

## 堆排
* 定义
  * 堆：对结构就是使用数组实现的完全二叉树结构；
  * 大根堆：完全二叉树中，每棵树的最大值都在顶部；
  * 小根堆：完全二叉树中，每棵树的最小值都在顶部；
* 基本操作
  * 堆结构的heapInsert和heapify；
  * 堆结构的增大和减少；
  * Java优先级队列就是堆结构；
  * 堆节点的左孩子节点 = 2*Index+1
  * 堆节点的右孩子节点 = 2*Index+2
  * 堆节点的父节点 = (Index-1)/2


## 总结

各算法复杂度

| 算法   | 时间复杂度    | 空间复杂度   | 稳定性 |
|------|----------|---------|-----|
| 选择排序 | O(N^2)   | O(1)    | ×   |
| 冒泡排序 | O(N^2)   | O(1)    | √   |
| 插入排序 | O(N^2)   | O(1)    | √   |
| 归并排序 | O(NlogN) | O(N)    | √   |
| 快速排序 | O(NlogN) | O(logN) | ×   |
| 堆排序  | O(NlogN) | O(1)    | ×   |

### 扩展
* 小和问题
* 荷兰国旗问题